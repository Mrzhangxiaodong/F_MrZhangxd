##  👑1.思路分析

* 相邻两个数两两相比，n[i]跟n[j+1]比，如果n[i]>n[j+1]，则将连个数进行交换；
* j++, 重复以上步骤，第一趟结束后，最大数就会被确定在最后一位，这就是冒泡排序又称大（小）数沉底；
* i++,重复以上步骤，直到i=n-1结束，排序完成。

## 🎒2.负杂度分析

* 不管原始数组是否有序，时间复杂度都是O（n2），因为没一个数都要与其他数比较一次，（n-1）2次，分解：n2+2n-1,  去掉低次幂和常数，剩下n2,所以最后的时间复杂度是n2
* 空间复杂度是O（1）,因为只定义了一个辅助变量，与n的大小无关，所以空间复杂度为O（1）

## 👝3.选择排序和冒泡排序的比较

* 时间负责度都是O（n2）
* 空间复杂度都是O（1）
* 选择排序是从第一位开始确定最大或最小的数，保证前面的数都是有序的，且都比后面的数小或大，冒泡排序是从最后一位开始确定最大或最小的数，保证后面的数都是有序的且都大于或小于前面的数。。

## 👜4.主要代码

```
import java.util.Arrays;
public class Maopao {
    public static void main(String[] args) {
        int[] n = new int[]{1,6,3,8,33,27,66,9,7,88};
        int temp;
        for (int i = 0; i < n.length-1; i++) {
            for (int j = 0; j <n.length-1; j++) {
                if(n[j]>n[j+1]){
                    temp = n[j];
                    n[j] = n[j+1];
                    n[j+1] = temp;
                }
            }
        }
        System.out.println(Arrays.toString(n));
    }
}

```
